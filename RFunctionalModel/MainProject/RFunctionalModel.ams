## ams_version=1.0

Model Main_RFunctionalModel {
    Section tests {
        Section GeneralTests {
            Procedure testRWorks {
                Body: {
                    block
                        R::executeScript("write('R works!!', '"+outputFile+"');");
                    
                        DetermineScalarTestFileOutputSuccessfull(outputFile,"R works!!");
                        onerror err do
                            HandleException(err);
                    endblock;
                }
            }
            Procedure testGetDataToUnknownIdentifierShouldFail {
                Body: {
                    block
                        R::executeScript("r<-aimms4r::GetData('unknownIdentifier');");
                    
                        MarkTestAsFailed("testGetDataToUnknownIdentifierShouldFail");
                        onerror err do
                            OnExpectedException();
                    endblock;
                }
            }
            Procedure testSetDataFromUnknownIdentifierShouldFail {
                Body: {
                    block
                        R::executeScript("aScalarString<-'initialValue'; aimms4r::SetData(aScalarString, 'unknownIdentifier');");
                    
                        MarkTestAsFailed("testSetDataFromUnknownIdentifierShouldFail");
                        onerror err do
                            OnExpectedException();
                    endblock;
                }
            }
        }
        Section RScripts {
            File initialize3DIdentifier {
                Name: "RScripts\\initialize3DIdentifier.r";
                Device: Disk;
                Mode: replace;
            }
            File fill3DIdentifierWithIntegerValues {
                Name: "RScripts\\fill3DIdentifierWithIntegerValues.r";
                Device: Disk;
                Mode: replace;
            }
            File fill3DIdentifierWithStringValues {
                Name: "RScripts\\fill3DIdentifierWithStringValues.r";
                Device: Disk;
                Mode: replace;
            }
            File fill3DIdentifierWithDoubleValues {
                Name: "RScripts\\fill3DIdentifierWithDoubleValues.r";
                Device: Disk;
                Mode: replace;
            }
            File fill3DIdentifierWithElemValues {
                Name: "RScripts\\fill3DIdentifierWithElemValues.r";
                Device: Disk;
                Mode: replace;
            }
            File rearrange3DDataFrame {
                Name: "RScripts\\rearrange3DDataFrame.r";
                Device: Disk;
                Mode: replace;
            }
        }
        Section Utilities {
            Section DataFrameFactory {
                Procedure Prepare3DDataFrame {
                    Arguments: (valueType,idName);
                    Body: {
                        executeRFromFile(initialize3DIdentifier);
                        
                        if valueType = 1 then
                            !Make integers
                            executeRFromFile(fill3DIdentifierWithIntegerValues);
                        elseif valueType = 2 then
                            !Make strings
                            executeRFromFile(fill3DIdentifierWithStringValues);
                        elseif valueType = 3 then
                            !Make doubles
                            executeRFromFile(fill3DIdentifierWithDoubleValues);
                        elseif valueType = 4 then
                            !Make elements
                            executeRFromFile(fill3DIdentifierWithElemValues);
                        endif;
                        
                        executeRFromFile(rearrange3DDataFrame);
                        
                        R::executeScript("aimms4r::SetData(df,'"+idName+"');");
                    }
                    Parameter valueType {
                        Property: Input;
                    }
                    StringParameter idName {
                        Property: Input;
                    }
                }
            }
            Procedure GenerateDiffFromAimmsAndRData {
                Arguments: (outputFilename,expectedIdName,actualIdName);
                Body: {
                    R::executeScript("  gt<-aimms4r::GetData('"+expectedIdName+"');"+
                                     "data<-aimms4r::GetData('"+actualIdName+"');"+
                                     "require(sqldf);"+
                                     "diff <- sqldf('SELECT * FROM gt EXCEPT SELECT * FROM data');"+
                                     "sink('"+outputFilename+"');print( paste0( nrow(diff) , ' ',nrow(data) ) );sink();");
                }
                StringParameter outputFilename {
                    Property: Input;
                }
                StringParameter expectedIdName {
                    Property: Input;
                }
                StringParameter actualIdName {
                    Property: Input;
                }
            }
            Procedure DetermineMultiDimTestFileOutputSuccessfull {
                Arguments: (outputFilename,expectedCardinality);
                Body: {
                    GetCurrentProcsCaller(currentProcedure);
                    
                    if FileExists(outputFilename) = 0 then
                        MarkTestAsFailed(currentProcedure);
                    else
                        !read the file
                        contents := FileRead(outputFilename);
                        if contents <> "[1] \"0 "+FormatString("%i",expectedCardinality)+'\"\n'  then 
                             MarkTestAsFailed(currentProcedure);
                        else
                             MarkTestAsSuccessfull(currentProcedure);
                        endif;
                    endif;
                }
                StringParameter outputFilename {
                    Property: Input;
                }
                Parameter expectedCardinality {
                    Property: Input;
                }
            }
            Procedure CheckMultiDimString {
                Arguments: (expected,actual);
                Body: {
                    for(i, c, di) do
                        shouldEndTest := DetermineMultiDimStringTestSuccessfull(expected(i,c, di), actual(i,c,di));
                        if shouldEndTest = 1 then
                            return 0;
                        endif;
                    endfor;
                    
                    return 1;
                }
                Parameter shouldEndTest {
                    InitialData: 0;
                }
                StringParameter expected {
                    IndexDomain: (i,c,di);
                    Property: Input;
                }
                StringParameter actual {
                    IndexDomain: (i,c,di);
                    Property: Input;
                }
            }
            Procedure CheckMultiDimElem {
                Arguments: (expected,actual);
                Body: {
                    for(i, c, di) do
                        shouldEndTest := DetermineMultiDimElemTestSuccessfull(expected(i,c, di), actual(i,c,di));
                        if shouldEndTest = 1 then
                            return 0;
                        endif;
                    endfor;
                    
                    return 1;
                }
                Parameter shouldEndTest {
                    InitialData: 0;
                }
                ElementParameter expected {
                    IndexDomain: (i,c,di);
                    Range: Cities;
                    Property: Input;
                }
                ElementParameter actual {
                    IndexDomain: (i,c,di);
                    Range: Cities;
                    Property: Input;
                }
            }
            Procedure CheckMultiDim {
                Arguments: (expected,actual);
                Body: {
                    for(i, c, di) do
                        shouldEndTest := DetermineMultiDimTestSuccessfull(expected(i,c, di), actual(i,c,di));
                        if shouldEndTest = 1 then
                            return 0;
                        endif;
                    endfor;
                    
                    return 1;
                }
                Parameter shouldEndTest {
                    InitialData: 0;
                }
                Parameter expected {
                    IndexDomain: (i,c,di);
                    Property: Input;
                }
                Parameter actual {
                    IndexDomain: (i,c,di);
                    Property: Input;
                }
            }
            Procedure OnExpectedException {
                Body: {
                    GetCurrentProcsCaller(caller);
                    MarkTestAsSuccessfull(caller);
                    errh::MarkAsHandled(err);
                }
                StringParameter caller;
            }
            Procedure executeRFromFile {
                Arguments: (rScriptFilename);
                Body: {
                    EnvironmentGetString("RUNNING_TEST_FOLDER",cwd);
                    if FileExists(rScriptFilename) = 0 then
                        return 0;
                    endif;

                    if SubString(cwd, StringLength(cwd) - 1, StringLength(cwd) -1 ) <> '/' then
                        rScriptFilename := cwd + "/" + rScriptFilename;
                    else
                        rScriptFilename := cwd + rScriptFilename;
                    endif;
                    
                    scriptContent := FileRead(rScriptFilename);
                    !R::executeScript("write( '"+cwd+"' ,'lol.txt',append=TRUE)");
                    R::executeScript(scriptContent);
                    return 1;
                }
                StringParameter scriptContent;
                StringParameter rScriptFilename {
                    Property: Input;
                }
            }
            Procedure HandleException {
                Arguments: (err);
                Body: {
                    GetCurrentProcsCaller(caller);
                    MarkTestAsFailed(caller);
                    ErrorMsgPerTest(StringToElement( AllIdentifiers, caller) ) := errh::Message(err);
                    errh::MarkAsHandled(err);
                }
                StringParameter caller;
                ElementParameter err {
                    Range: errh::PendingErrors;
                }
            }
            Procedure DetermineScalarTestFileOutputSuccessfull {
                Arguments: (outputFilename,value);
                Body: {
                    GetCurrentProcsCaller(currentProcedure);
                    
                    if FileExists(outputFilename) = 0 then
                        MarkTestAsFailed(currentProcedure);
                    else
                        !read the file
                        contents := FileRead(outputFilename);
                        if contents <> value +"\n" then 
                             MarkTestAsFailed(currentProcedure);
                        else
                             MarkTestAsSuccessfull(currentProcedure);
                        endif;
                    endif;
                }
                StringParameter currentProcedure;
                StringParameter outputFilename;
                StringParameter value {
                    Property: Input;
                }
            }
            Procedure DetermineScalarTestSuccessfull {
                Arguments: (pred);
                Body: {
                    GetCurrentProcsCaller(currentProcedure);
                    if pred = 0 then
                        MarkTestAsFailed(currentProcedure);
                    else
                        MarkTestAsSuccessfull(currentProcedure);
                    endif;
                }
                StringParameter currentProcedure;
                Parameter pred {
                    Property: Input;
                }
            }
            Procedure DetermineMultiDimTestSuccessfull {
                Arguments: (actual,expected);
                Body: {
                    
                    GetCurrentProcsCaller(currentProcedure);
                    if actual <> expected then
                        MarkTestAsFailed(currentProcedure);
                        return 1;
                    endif;
                    
                    MarkTestAsSuccessfull(currentProcedure);
                    return 0;
                }
                StringParameter currentProcedure;
                Parameter actual {
                    Property: Input;
                }
                Parameter expected {
                    Property: Input;
                }
            }
            Procedure DetermineMultiDimStringTestSuccessfull {
                Arguments: (actual,expected);
                Body: {
                    
                    GetCurrentProcsCaller(currentProcedure);
                    if actual <> expected then
                        MarkTestAsFailed(currentProcedure);
                        return 1;
                    endif;
                    
                    MarkTestAsSuccessfull(currentProcedure);
                    return 0;
                }
                StringParameter currentProcedure;
                StringParameter actual {
                    Property: Input;
                }
                StringParameter expected {
                    Property: Input;
                }
            }
            Procedure DetermineMultiDimElemTestSuccessfull {
                Arguments: (actual,expected);
                Body: {
                    
                    GetCurrentProcsCaller(currentProcedure);
                    if actual <> expected then
                        MarkTestAsFailed(currentProcedure);
                        return 1;
                    endif;
                    
                    MarkTestAsSuccessfull(currentProcedure);
                    return 0;
                }
                StringParameter currentProcedure;
                ElementParameter actual {
                    Range: Cities;
                    Property: Input;
                }
                ElementParameter expected {
                    Range: Cities;
                    Property: Input;
                }
            }
            Procedure MarkTestAsSuccessfull {
                Arguments: (testName);
                Body: {
                    ErrorPerTest(StringToElement( AllIdentifiers, testName) ) := 2;
                    ErrorMsgPerTest(StringToElement( AllIdentifiers, testName) ) := "";
                }
                StringParameter testName {
                    Property: Input;
                }
            }
            Procedure MarkTestAsFailed {
                Arguments: (testName);
                Body: {
                    ErrorPerTest(StringToElement( AllIdentifiers, testName) ) := 1;
                }
                StringParameter testName {
                    Property: Input;
                }
            }
            Procedure GetCurrentProcsCaller {
                Arguments: (theCaller);
                Body: {
                    noLocs := callerNumberOfLocations();
                    depth := 1;
                    
                    while depth <= noLocs do
                        res := callerNode(depth);
                        stringRes := FormatString("%e", res );
                        theCaller := stringRes;
                        if FindString(theCaller, runnableTestPrefix) = 1 then
                            break;
                        endif;
                        depth += 1;
                    endwhile;
                }
                Parameter depth;
                Parameter noLocs;
                StringParameter theCaller {
                    Property: Output;
                    InitialData: "";
                }
            }
            Procedure GetCurrentProc {
                Arguments: (theCaller);
                Body: {
                    res := callerNode(1);
                    stringRes := FormatString("%e", res );
                    theCaller := stringRes;
                }
                StringParameter theCaller {
                    Property: Output;
                    InitialData: "";
                }
            }
            ElementParameter err {
                Range: errh::PendingErrors;
            }
            ElementParameter res {
                Range: AllIdentifiers;
            }
            StringParameter stringRes;
        }
        Section ScalarTests {
            StringParameter contents {
                InitialData: "";
            }
            StringParameter outputFilename {
                InitialData: "results.txt";
            }
            File outputFile {
                Name: outputFilename;
                Device: Disk;
                Mode: replace;
            }
            Parameter aDoubleParameter {
                Property: Double;
            }
            Parameter anIntegerParameter {
                Range: integer;
                Property: Integer;
            }
            StringParameter aStringParameter;
            ElementParameter anElementParameter {
                Range: CitySet;
            }
            Set CitySet {
                Index: city;
                InitialData: data {'Amsterdam','Utrecht','Haarlem'};
            }
            Section GetData {
                Procedure testGetScalarDouble {
                    Body: {
                        block
                            aDoubleParameter := 3.14;
                        
                            R::executeScript("r<-aimms4r::GetData('aDoubleParameter');write(r,'"+outputFilename+"')");
                        
                            DetermineScalarTestFileOutputSuccessfull(outputFilename,FormatString("%>.2n",aDoubleParameter));
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testGetScalarInteger {
                    Body: {
                        block
                            anIntegerParameter := 5;
                        
                            R::executeScript("r<-aimms4r::GetData('anIntegerParameter');write(r,'"+outputFilename+"')");
                        
                            DetermineScalarTestFileOutputSuccessfull(outputFilename,FormatString("%i",anIntegerParameter));
                        
                             onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testGetScalarString {
                    Body: {
                        block
                            aStringParameter := "aValue";
                        
                            R::executeScript("r<-aimms4r::GetData('aStringParameter');write(r,'"+outputFilename+"')");
                        
                            DetermineScalarTestFileOutputSuccessfull(outputFilename,aStringParameter);
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testGetScalarElement {
                    Body: {
                        block;
                            anElementParameter := StringToElement(CitySet, "Amsterdam");
                        
                            R::executeScript("r<-aimms4r::GetData('anElementParameter');write(r,'"+outputFilename+"')");
                        
                            DetermineScalarTestFileOutputSuccessfull(outputFilename,anElementParameter);
                        
                             onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
            }
            Section SetData {
                Procedure testSetScalarDouble {
                    Body: {
                        block
                            aDoubleParameter := 0;
                            R::executeScript("aimms4r::SetData(3.14,'aDoubleParameter');");
                        
                            DetermineScalarTestSuccessfull(aDoubleParameter = 3.14);
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testSetScalarString {
                    Body: {
                        block
                            aStringParameter := "initialValue";
                            R::executeScript("aimms4r::SetData('aValue','aStringParameter');");
                        
                            DetermineScalarTestSuccessfull(aStringParameter = 'aValue');
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testSetScalarInteger {
                    Body: {
                        block
                            anIntegerParameter := 0;
                            R::executeScript("aimms4r::SetData(5,'anIntegerParameter');");
                        
                            DetermineScalarTestSuccessfull(anIntegerParameter = 5);
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testSetScalarElement {
                    Body: {
                        block
                            anElementParameter := 'Utrecht';
                            R::executeScript("aimms4r::SetData('Amsterdam','anElementParameter');");
                        
                            DetermineScalarTestSuccessfull(anElementParameter ='Amsterdam');
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
            }
        }
        Section MultiDimensionalTests {
            Set DoubleSet {
                Index: di;
                InitialData: data {3.1, 7.2, 8.3};
            }
            Parameter shouldEndTest {
                InitialData: 0;
            }
            Set Cities {
                Index: c;
                InitialData: data {'Amsterdam','Haarlem'};
            }
            Set Countries {
                Index: co;
                InitialData: data {'Netherlands','Greece'};
            }
            Set anIntegerSubset {
                SubsetOf: Integers;
                Index: i, j;
                InitialData: data{1..3};
            }
            Parameter MultiDimIntegerV {
                IndexDomain: (i,c,di);
                Property: Integer;
            }
            Parameter GroundTruthMultiDimIntegerV {
                IndexDomain: (i,c,di);
                Property: Integer;
            }
            StringParameter MultiDimStringV {
                IndexDomain: (i,c,di);
            }
            StringParameter GroundTruthMultiDimStringV {
                IndexDomain: (i,c,di);
            }
            Parameter MultiDimDoubleV {
                IndexDomain: (i,c,di);
                Property: Double;
            }
            Parameter GroundTruthMultiDimDoubleV {
                IndexDomain: (i,c,di);
                Property: Double;
            }
            ElementParameter MultiDimElemV {
                IndexDomain: (i,c,di);
                Range: Cities;
            }
            ElementParameter GroundTruthMultiDimElemV {
                IndexDomain: (i,c,di);
                Range: Cities;
            }
            Section SetMultiData {
                Procedure testSetMultiIntegerData {
                    Body: {
                        block
                            empty MultiDimIntegerV;
                            empty GroundTruthMultiDimIntegerV;
                        
                            Prepare3DDataFrame(1,"MultiDimIntegerV");
                        
                            GroundTruthMultiDimIntegerV(i,c,di) := card(di) * (  card(c)*i + ord(c) ) + ord(di)  ;
                            CheckMultiDim(GroundTruthMultiDimIntegerV(i,c,di), MultiDimIntegerV(i,c,di) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testSetMultiDoubleData {
                    Body: {
                        block
                            empty MultiDimDoubleV;
                            empty GroundTruthMultiDimDoubleV;
                        
                            Prepare3DDataFrame(3,"MultiDimDoubleV");
                        
                            GroundTruthMultiDimDoubleV(i,c,di) := card(di) * (  card(c)*i + ord(c) ) + ord(di) + .1234 ;
                            CheckMultiDim(GroundTruthMultiDimDoubleV(i,c,di), MultiDimDoubleV(i,c,di) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testSetMultiStringData {
                    Body: {
                        block
                            empty MultiDimStringV;
                            empty GroundTruthMultiDimStringV;
                        
                            Prepare3DDataFrame(2,"MultiDimStringV");
                        
                            GroundTruthMultiDimStringV(i,c,di) :=  FormatString( "Value => %i", card(di) * (  card(c)*i + ord(c) ) + ord(di)  ) ;
                            CheckMultiDimString(GroundTruthMultiDimStringV(i,c,di), MultiDimStringV(i,c,di) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testSetMultiElementData {
                    Body: {
                        block
                            empty MultiDimElemV;
                            empty GroundTruthMultiDimElemV;
                        
                            Prepare3DDataFrame(4,"MultiDimElemV");
                        
                            for (i,c,di) do
                                 if( Mod( ord(i) + ord(c) + ord(di) , 2 )   = 0) then
                                     GroundTruthMultiDimElemV(i,c,di) :=  'Amsterdam' ;
                                 else
                                     GroundTruthMultiDimElemV(i,c,di) :=  'Haarlem' ;
                                 endif;
                            endfor;
                        
                            CheckMultiDimElem(GroundTruthMultiDimElemV(i,c,di), MultiDimElemV(i,c,di) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
            }
            Section GetMultiData {
                Procedure testGetMultiDoubleData {
                    Body: {
                        block
                            empty MultiDimDoubleV;
                            empty GroundTruthMultiDimDoubleV;
                        
                            GroundTruthMultiDimDoubleV(i,c,di) := card(di) * (  card(c)*i + ord(c) ) + ord(di) + .1234 ;
                            Prepare3DDataFrame(3,"MultiDimDoubleV");
                        
                            GenerateDiffFromAimmsAndRData(outputFilename,  "GroundTruthMultiDimDoubleV" , "MultiDimDoubleV" ); 
                        
                            DetermineMultiDimTestFileOutputSuccessfull(outputFilename, card ( GroundTruthMultiDimDoubleV ) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testGetMultiStringData {
                    Body: {
                        block
                            empty MultiDimStringV;
                            empty GroundTruthMultiDimStringV;
                        
                            GroundTruthMultiDimStringV(i,c,di) :=  FormatString( "Value => %i", card(di) * (  card(c)*i + ord(c) ) + ord(di)  ) ;
                            Prepare3DDataFrame(2,"MultiDimStringV");
                        
                            GenerateDiffFromAimmsAndRData(outputFilename,  "GroundTruthMultiDimStringV" , "MultiDimStringV" ); 
                        
                            DetermineMultiDimTestFileOutputSuccessfull(outputFilename, card ( GroundTruthMultiDimStringV ) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testGetMultiElementData {
                    Body: {
                        block
                            empty MultiDimElemV;
                            empty GroundTruthMultiDimElemV;    
                        
                            for (i,c,di) do
                                if( Mod( ord(i) + ord(c) + ord(di) , 2 )   = 0) then
                                    GroundTruthMultiDimElemV(i,c,di) :=  'Amsterdam' ;
                                else
                                    GroundTruthMultiDimElemV(i,c,di) :=  'Haarlem' ;
                                endif;
                            endfor;
                        
                        
                            Prepare3DDataFrame(4,"MultiDimElemV");
                        
                            GenerateDiffFromAimmsAndRData(outputFilename,  "GroundTruthMultiDimElemV" , "MultiDimElemV" ); 
                        
                            DetermineMultiDimTestFileOutputSuccessfull(outputFilename, card ( GroundTruthMultiDimElemV ) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
                Procedure testGetMultiIntegerData {
                    Body: {
                        block
                            empty MultiDimIntegerV;
                            empty GroundTruthMultiDimIntegerV;
                        
                            GroundTruthMultiDimIntegerV(i,c,di) := card(di) * (  card(c)*i + ord(c) ) + ord(di)  ;
                            Prepare3DDataFrame(1,"MultiDimIntegerV");
                        
                            GenerateDiffFromAimmsAndRData(outputFilename,  "GroundTruthMultiDimIntegerV" , "MultiDimIntegerV" ); 
                        
                            DetermineMultiDimTestFileOutputSuccessfull(outputFilename, card ( GroundTruthMultiDimIntegerV ) );
                        
                            onerror err do
                                HandleException(err);
                        endblock;
                    }
                }
            }
        }
        Procedure RunTests {
            Body: {
                for (testProc) do
                     aProc := testProc;
                     apply(aProc);
                endfor;
            }
        }
    }
    StringParameter resultOutputFilename {
        InitialData: "testResults.txt";
    }
    StringParameter runnableTestPrefix {
        InitialData: "test";
    }
    StringParameter stringValue;
    StringParameter cwd;
    StringParameter currentProcedure {
        InitialData: "";
    }
    ElementParameter aProc {
        Range: Procedures;
        Default: 'MainInitialization';
    }
    Set Procedures {
        SubsetOf: AllProcedures;
        Index: proc;
        InitialData: AllProcedures;
    }
    Set TestProcedures {
        SubsetOf: AllProcedures;
        Index: testProc;
        InitialData: data {};
    }
    Parameter ErrorPerTest {
        IndexDomain: testProc;
    }
    StringParameter ErrorMsgPerTest {
        IndexDomain: testProc;
    }
    File resultOutputFile {
        Name: resultOutputFilename;
        Device: Disk;
        Mode: replace;
    }
    Procedure Prepare {
        Body: {
            empty ErrorPerTest;
            empty TestProcedures;
            
            !Fill TestProcedures set with the Procedure names that contain the string 
            !that is stored in the parameter runnableTestPrefix
            for (proc) do
            
                 if StringOccurrences(proc,runnableTestPrefix) <> 0 then
                      !DialogMessage(proc);
                      aProc := proc;
                      SetElementAdd(TestProcedures, aProc, aProc);
                 endif;
            endfor;
            
            !Initialize the ErrorPerTest identifier with -1. In case there was an error on that specific test
            !ErrorPerTest(testProc) := 1, otherwise it should get ErrorPerTest(testProc) := 2
            
            ErrorPerTest(testProc) := -1;
            ErrorMsgPerTest(testProc) := "";
        }
    }
    Procedure MainInitialization {
        Comment: "Add initialization statements here that do NOT require any library being initialized already.";
    }
    Procedure PostMainInitialization {
        Comment: {
            "Add initialization statements here that require that the libraries are already initialized properly,
            or add statements that require the Data Management module to be initialized."
        }
    }
    Procedure InstallRPackages {
        Body: {
            R::executeScript("if(!require(sqldf)){install.packages('sqldf',repos='http://cran.us.r-project.org');library(sqldf);}");
        }
    }
    Procedure MainExecution {
        Body: {
            InstallRPackages;
            Prepare;
            RunTests;
            WriteResults;
        }
    }
    Procedure WriteResults {
        Body: {
            !If there are no errors, no output file should be created in the end
            !Otherwise write test run results there as a json string
            
            FileDelete(resultOutputFilename);
            
            maxErrors :=   Count (  testProc | ErrorPerTest(testProc) <> 2   ) ;
            !If no errors, return 0
            if maxErrors = 0 then
                return 0;
            endif;
            
            !If there were errors, create a Json like structure in the file
            cnt := 0;
            !put resultOutputFile;
            put "{";
            
            
            
            for (testProc) do
                if ErrorPerTest(testProc) <> 2 then
                    !DialogMessage("\""+testProc+"\": { \"msg\" : \""+FindReplaceStrings( ErrorMsgPerTest(testProc) , '"',"\\\"" )+"\" }");
                    put "\""+testProc+"\": { \"msg\" : \""+FindReplaceStrings( ErrorMsgPerTest(testProc) , '"',"\\\"")+"\" }";
                    if cnt + 1 <> maxErrors then
                        put ",";
                    endif;
                    put ;
                    cnt += 1;
                endif;
            endfor;
            
            put "}";
            putclose;
            return 1;
        }
        Parameter cnt;
        Parameter maxErrors;
    }
    Procedure PreMainTermination {
        Body: {
            return DataManagementExit();
        }
        Comment: {
            "Add termination statements here that require all libraries to be still alive.
            Return 1 if you allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence."
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that do not require all libraries to be still alive.
            Return 1 to allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence.
            It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
        }
    }
}
